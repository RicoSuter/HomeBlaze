@using System.Threading
@using HomeBlaze.Abstractions.Services;
@using HomeBlaze.Abstractions;
@using HomeBlaze.Components.Extensions;
@using HomeBlaze.Components.Graphs;
@using MudBlazor
@using Radzen.Blazor

@inject IStateManager StateManager
@inject IThingManager ThingManager

<MudDialog>
    <TitleContent>@(Thing?.Title): @PropertyName</TitleContent>
    <DialogContent>
        <MudSelect T="int" Label="Type" ValueChanged="(value) => RefreshAsync(value)" Value="NumberOfHours">
            <MudSelectItem Value="1" T="int">1 Hour</MudSelectItem>
            <MudSelectItem Value="4" T="int">4 Hours</MudSelectItem>
            <MudSelectItem Value="6" T="int">6 Hours</MudSelectItem>
            <MudSelectItem Value="12" T="int">12 Hours</MudSelectItem>
            <MudSelectItem Value="24" T="int">1 Day</MudSelectItem>
            <MudSelectItem Value="48" T="int">2 Days</MudSelectItem>
            <MudSelectItem Value="168" T="int">7 Days</MudSelectItem>
            <MudSelectItem Value="720" T="int">30 Days</MudSelectItem>
        </MudSelect>
        <br />

        <div style="height: calc(100vh - 150px); overflow-y: auto;">
            @if (IsLoading)
            {
                <span>Loading data...</span>
            }
            else
            {
                @if (ChartItems.Length > 0)
                {
                    <RadzenChart Style="width: 100%; height: calc(100vh - 170px)">
                        <RadzenLegend Visible="false" Position="LegendPosition.Bottom"></RadzenLegend>
                        <RadzenLineSeries Smooth="false"
                                  Data="@ChartItems"
                                  CategoryProperty="Date"
                                  Title="@PropertyName"
                                  LineType="LineType.Solid"
                                  ValueProperty="Value">
                            <RadzenMarkers MarkerType="MarkerType.None" />
                        </RadzenLineSeries>
                        <RadzenValueAxis>
                            <RadzenGridLines Visible="true" />
                        </RadzenValueAxis>
                        <RadzenCategoryAxis Formatter="@FormatTime">
                        </RadzenCategoryAxis>
                    </RadzenChart>
                }
                else if (Values.Any())
                {
                    <pre>
                        @foreach (var val in Values.Reverse())
                        {
                            @($"{val.DateTime}\n    {val.RawValue ?? "(null)"}\n\n")
                        }
                    </pre>
                }
            }
        </div>
    </DialogContent>
    <DialogActions>
        <span style="position: absolute; left: 12px">
            <strong>Average: </strong>@Math.Round(Average, 2)&nbsp;&nbsp;&nbsp;
            <strong>Max: </strong>@Math.Round(Maximum, 2)&nbsp;&nbsp;&nbsp;<br />
            <strong>Min: </strong>@Math.Round(Minimum, 2)&nbsp;&nbsp;&nbsp;
            <strong>Diff: </strong>@Math.Round(Difference, 2)
        </span>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => DialogInstance?.Close(null))" Class="px-10">Close</MudButton>
    </DialogActions>
</MudDialog>

@code {
    private bool IsInitialized { get; set; } = false;
    private bool IsLoading { get; set; } = true;

    private int NumberOfHours { get; set; } = 24;
    private bool IsBoolean { get; set; } = false;

    private decimal Average { get; set; } = 0;
    private decimal Minimum { get; set; } = 0;
    private decimal Maximum { get; set; } = 0;
    private decimal Difference { get; set; } = 0;

    private ChartItem[] ChartItems { get; set; } = new ChartItem[0];
    private ChartItem[] Values { get; set; } = new ChartItem[0];

    [Parameter]
    public IThing? Thing { get; set; }

    [Parameter]
    public string? PropertyName { get; set; }

    [CascadingParameter]
    public MudDialogInstance? DialogInstance { get; set; }

    public static async Task ShowAsync(IDialogService dialogService, IThing thing, string propertyName)
    {
        await dialogService.Show<StateHistoryDialog>(string.Empty,
            new DialogParameters
            {
                { "Thing", thing },
                { "PropertyName", propertyName }
            },
            new DialogOptions
            {
                CloseOnEscapeKey = true,
                NoHeader = true,
                FullScreen = true
            }).Result;
    }

    string FormatTime(object value)
    {
        return ((DateTime)value).ToString("HH:mm");
    }

    protected override async Task OnInitializedAsync()
    {
        IsInitialized = true;
        await RefreshAsync(24);
    }

    private async Task RefreshAsync(int numberOfHours)
    {
        if (!IsInitialized)
        {
            return;
        }

        NumberOfHours = numberOfHours;
        IsLoading = true;

        var delay = Task.Delay(500);

        var startDate = DateTimeOffset.Now.AddHours(numberOfHours * -1);
        var endDate = DateTimeOffset.Now;
        var duration = endDate - startDate;
        var state = ThingManager.TryGetPropertyState(Thing?.Id, PropertyName, true);

        var rawValues = await StateManager.ReadStateAsync<object>(
            Thing!.Id!, PropertyName!, startDate, endDate, CancellationToken.None);

        Values = rawValues
            .Select((v, i) => new ChartItem
            {
                Index = i,
                DateTime = v.Item1,
                RawValue = v.Item2
            })
            .OrderBy(v => v.DateTime)
            .ToArray();

        await delay;

        try
        {
            ChartItems = ChartSeriesUtilities.CleanUp(state, Values, numberOfHours);
           
            if (ChartItems.Any())
            {
                Minimum = (decimal)ChartItems.Select(v => v.Value).Min();
                Maximum = (decimal)ChartItems.Select(v => v.Value).Max();
                Average = ChartItems.GetSegments().WeightedAverage(
                    s => (decimal)((s.First.Value + s.Second.Value) / 2.0),
                    s => (decimal)(s.Second.Date - s.First.Date).TotalMilliseconds);
                Difference = Maximum - Minimum;
            }
        }
        catch
        {
            ChartItems = new ChartItem[0];
        }
        finally
        {
            IsLoading = false;
        }

        await InvokeAsync(StateHasChanged);
    }
}