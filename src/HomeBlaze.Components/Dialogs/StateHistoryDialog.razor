@using System.Threading
@using HomeBlaze.Abstractions.Services;
@using HomeBlaze.Abstractions;
@using HomeBlaze.Components.Extensions;
@using HomeBlaze.Components.Graphs;
@using HomeBlaze.Components.Inputs
@using MudBlazor
@using Radzen.Blazor

@inject IStateManager StateManager
@inject IThingManager ThingManager

<MudDialog>
    <TitleContent>@(Thing?.Title): @PropertyName</TitleContent>
    <DialogContent>
        <MudButton Variant="Variant.Filled" Color="Color.Primary"
                   Disabled="@IsLoading"
                   Style="float: right; margin-left: 16px; margin-top: 8px"
                   OnClick="(() => ToggleDetails())">
            @(ShowDetails ? "Show Chart" : "Edit Series")
        </MudButton>

        <MudSelect T="int" Label="Type" @bind-Value="NumberOfHours" Disabled="@IsLoading">
            <MudSelectItem Value="1" T="int">1 Hour</MudSelectItem>
            <MudSelectItem Value="4" T="int">4 Hours</MudSelectItem>
            <MudSelectItem Value="6" T="int">6 Hours</MudSelectItem>
            <MudSelectItem Value="12" T="int">12 Hours</MudSelectItem>
            <MudSelectItem Value="24" T="int">1 Day</MudSelectItem>
            <MudSelectItem Value="48" T="int">2 Days</MudSelectItem>
            <MudSelectItem Value="168" T="int">7 Days</MudSelectItem>
            <MudSelectItem Value="720" T="int">30 Days</MudSelectItem>
        </MudSelect>

        <br />
        <div style="height: calc(100vh - 150px); overflow-y: auto;">
            @if (ShowDetails)
            {
                @foreach (var series in AdditionalSeries)
                {
                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                   OnClick="@(() => AdditionalSeries.Remove(series))" Style="float: right"
                                   Variant="Variant.Filled" Color="Color.Error"></MudIconButton>

                    <h2>Series @(AdditionalSeries.IndexOf(series) + 1)</h2>
                    <ThingSelect Label="Thing ID"
                    @bind-ThingId="series.ThingId"
                                 Required="false" />

                    <ThingPropertySelect Label="Property"
                    @bind-PropertyName="series.PropertyName"
                                         ThingId="@series.ThingId"
                                         Disabled="@(series.ThingId == null)"
                                         Required="false" />

                    <br />
                    <br />
                }

                <MudButton StartIcon="@Icons.Material.Filled.Add"
                           OnClick="@(() => AdditionalSeries.Add(new AdditionalSeriesDto()))"
                           Variant="Variant.Filled" Color="Color.Primary">Additional Series</MudButton>
            }
            else
            {
                @if (IsLoading)
                {
                    <span>Loading data...</span>
                }
                else
                {
                    @if (_series.Any(s => s.Value.Length > 0))
                    {
                        <RadzenChart Style="width: 100%; height: calc(100vh - 170px)">
                            <RadzenLegend Visible="false" Position="LegendPosition.Bottom"></RadzenLegend>
                            @foreach (var series in _series)
                            {
                                <RadzenLineSeries Smooth="false"
                                                  Data="@series.Value"
                                                  CategoryProperty="Date"
                                                  Title="@series.Key"
                                                  LineType="LineType.Solid"
                                                  StrokeWidth="4"
                                                  ValueProperty="Value">
                                    <RadzenMarkers MarkerType="MarkerType.None" />
                                </RadzenLineSeries>
                            }
                            <RadzenValueAxis>
                                <RadzenGridLines Visible="true" />
                            </RadzenValueAxis>
                            <RadzenCategoryAxis Formatter="@FormatTime">
                            </RadzenCategoryAxis>
                        </RadzenChart>
                    }
                    else if (Values.Any())
                    {
                        <pre>
                            @foreach (var val in Values.Reverse())
                            {
                                @($"{val.DateTime}\n    {val.RawValue ?? "(null)"}\n\n")
                            }
                        </pre>
                    }
                }
            }
        </div>
    </DialogContent>
    <DialogActions>
        @if (!ShowDetails && !IsLoading)
        {
            <span style="position: absolute; left: 12px">
                <strong>Average: </strong>@Math.Round(Average, 2)&nbsp;&nbsp;&nbsp;
                <strong>Max: </strong>@Math.Round(Maximum, 2)&nbsp;&nbsp;&nbsp;<br />
                <strong>Min: </strong>@Math.Round(Minimum, 2)&nbsp;&nbsp;&nbsp;
                <strong>Diff: </strong>@Math.Round(Difference, 2)
            </span>
        }
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => DialogInstance?.Close(null))" Class="px-10">Close</MudButton>
    </DialogActions>
</MudDialog>

@code {
    private int _numberOfHours = 24;

    private bool IsInitialized { get; set; } = false;
    private bool IsLoading { get; set; } = true;
    private bool ShowDetails { get; set; } = false;

    private int NumberOfHours
    {
        get => _numberOfHours;
        set
        {
            _numberOfHours = value;
            
            if (!ShowDetails)
            {
                Task.Run(async () => await RefreshAsync());
            }
        }
    }

    private decimal Average { get; set; } = 0;
    private decimal Minimum { get; set; } = 0;
    private decimal Maximum { get; set; } = 0;
    private decimal Difference { get; set; } = 0;

    private List<AdditionalSeriesDto> AdditionalSeries { get; } = new List<AdditionalSeriesDto>();

    class AdditionalSeriesDto
    {
        public string? ThingId { get; set; }

        public string? PropertyName { get; set; }
    }

    private ChartItem[] Values { get; set; } = new ChartItem[0];

    private Dictionary<string, ChartItem[]> _series = new Dictionary<string, ChartItem[]>();

    [Parameter]
    public IThing? Thing { get; set; }

    [Parameter]
    public string? PropertyName { get; set; }

    [CascadingParameter]
    public MudDialogInstance? DialogInstance { get; set; }

    public async void ToggleDetails()
    {
        ShowDetails = !ShowDetails;
        await InvokeAsync(StateHasChanged);

        if (!ShowDetails)
        {
            await RefreshAsync();
        }
    }

    public static async Task ShowAsync(IDialogService dialogService, IThing thing, string propertyName)
    {
        await dialogService.Show<StateHistoryDialog>(string.Empty,
            new DialogParameters
                        {
                { "Thing", thing },
                { "PropertyName", propertyName }
                        },
            new DialogOptions
                {
                    CloseOnEscapeKey = true,
                    NoHeader = true,
                    FullScreen = true
                }).Result;
    }

    string FormatTime(object value)
    {
        return ((DateTime)value).ToString("HH:mm");
    }

    protected override async Task OnInitializedAsync()
    {
        IsInitialized = true;

        AdditionalSeries.Add(new AdditionalSeriesDto
        {
            ThingId = Thing?.Id,
            PropertyName = PropertyName
        });

        await RefreshAsync();
    }

    private async Task RefreshAsync()
    {
        if (!IsInitialized)
        {
            return;
        }

        IsLoading = true;

        var delay = Task.Delay(500);

        var startDate = DateTimeOffset.Now.AddHours(NumberOfHours * -1);
        var endDate = DateTimeOffset.Now;
        var duration = endDate - startDate;

        var rawValues = await StateManager.ReadStateAsync<object>(
            Thing!.Id!, PropertyName!, startDate, endDate, CancellationToken.None);

        Values = rawValues
            .Select((v, i) => new ChartItem
                {
                    Index = i,
                    DateTime = v.Item1,
                    RawValue = v.Item2
                })
            .OrderBy(v => v.DateTime)
            .ToArray();

        await delay;

        try
        {
            _series.Clear();

            foreach (var series in AdditionalSeries.Where(s => !string.IsNullOrEmpty(s.ThingId) && !string.IsNullOrEmpty(s.PropertyName)))
            {
                var thing = ThingManager.TryGetById(series.ThingId);
                var state = ThingManager.TryGetPropertyState(series.ThingId, series.PropertyName, true);

                var rawValues2 = await StateManager.ReadStateAsync<object>(
                    series.ThingId!, series.PropertyName!, startDate, endDate, CancellationToken.None);

                var values2 = rawValues2
                    .Select((v, i) => new ChartItem
                        {
                            Index = i,
                            DateTime = v.Item1,
                            RawValue = v.Item2
                        })
                    .OrderBy(v => v.DateTime)
                    .ToArray();

                var chartItems2 = ChartSeriesUtilities.CleanUp(state, values2, NumberOfHours);

                _series[thing?.Title + ": " + series.PropertyName] = chartItems2;
            }

            var chartItems = _series.First().Value;
            if (chartItems.Any())
            {
                Minimum = (decimal)chartItems.Select(v => v.Value).Min();
                Maximum = (decimal)chartItems.Select(v => v.Value).Max();
                Average = chartItems.GetSegments().WeightedAverage(
                    s => (decimal)((s.First.Value + s.Second.Value) / 2.0),
                    s => (decimal)(s.Second.Date - s.First.Date).TotalMilliseconds);
                Difference = Maximum - Minimum;
            }
        }
        catch
        {
            _series = new Dictionary<string, ChartItem[]>();
        }
        finally
        {
            IsLoading = false;
        }

        await InvokeAsync(StateHasChanged);
    }
}